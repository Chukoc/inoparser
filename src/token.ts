import { runInThisContext } from "vm"

export const TokenType = {
	// EOF
	ILLEGAL : "ILLEGAL",
	EOF : "EOF",

	// ArtmeticOperator
	PLUS : "+",
	MINUS : "-",
	STAR : "*",
	SLASH : "/",
	MOD : "%", 
	
	// LogicalOperator
	LOGNOT : "!",
	LOGAND : "&&",
	LOGOR : "||",

	// BitwiseOperator
	BITNOT : "~",
	BITAND : "&",
	BITOR : "|",
	BITXOR : "^",
	LSHIFT : "<<",
	RSHIFT : ">>",

	// Assign
	ASSIGN : "=",
	PULEQ : "+=",
	MINEQ : "-=",
	MULEQ : "*=",
	DIVEQ : "/=",
	MODEQ : "%=",
	ANDEQ : "&=",
	OREQ : "|=",
	XOREQ : "^=",
	LSHIFTEQ : "<<=",
	RSHIFTEQ : ">>=",
	INC : "++",
	DEC : "--",

	// Compare Operator
	EQ : "==",
	NEQ : "!=",
	LT : "<",
	LEQ : "<=",
	GT : ">",
	GEQ : ">=",
	QUESTION : "?",

	// Delemeter
	DOUBLEQ : '"',
	QUOTE : "'",
	COMMA : ",",
	PILIOD : ".",
	COLON : ":",
	SEMICOLON : ";",
	LPARLEN : "(",
	RPARLEN : ")",
	LBRAC : "{",
	RBRAC : "}",
	LBRACKET : "[",
	RBRACKET : "]",

	// Accesor
	FUNCTION : "()",
	ARRAY : "[]",
	ARROW : "->",
	POINTARROW : "->*",
	POINTAPILIOD : ".*",
	NAMERES : "::",
	EXTENTION : "...",

	// Literal
	NUMBER : "NUMBER",
	STRING : "STRING",
	CHARLIT : "CHARLIT",
	IDENT  : "IDENT",

	// PreProcess
	CONTROL : "#",
	DOUBLESH : "##",

	// keywords
	ALIGNAS : "alignas",
	ALIGNOF : "alignof",
	ANDLIT : "and",
	ANDEQLIT : "and_eq",
	ASM : "asm",
	AUTO : "auto",
	BITANDLIT: "bitand",
	BITORLIT: "bitor",
	BOOL : "bool",
	BREAK : "break",
	CASE : "case",
	CATCH : "catch",
	CHAR : "char",
	CHAR8T : "char8_t", 
	CHAR16T : "char16_t", 
	CHAR32T : "char32_t", 
	CLASS : "class",
	COMPL : "compl",
	CONCEPT : "concept",
	CONST : "const",
	CONSTCAST : "const_cast",
	CONSTEVAL : "consteval",
	CONSTEXPR : "constexpr",
	CONSTINIT : "constinit",
	CONTINUE : "continue",
	COAWAIT : "co_await",
	CORETURN : "co_return",
	COYIELD : "co_yield",
	DECLTYPE : "declytype",
	DELETE : "delete",
	DO : "do",
	DOUBLE : "double",
	DYNAMICAST : "dynamic_cast",
	ELSE : "else",
	ENUM : "enum",
	EXPLICIT : "explicit",
	EXPORT : "export",
	EXTERN : "extern",
	FALSE : "false",
	FLOAT : "float",
	FOR : "for", 
	FRIEND : "friend",
	GOTO : "goto",
	IF : "if",
	INLINE : "inline",
	INT : "int",
	LONG : "long",
	MUTABLE : "mutable",
	NAMESPACE : "namespace",
	NEW : "new",
	NOEXCEPT : "noexcept",
	NOTLIT : "not",
	NOTEQLIT : "not_eq",
	NULLPTR : "nullptr",
	OPERATOR : "operator",
	ORLIT : "or",
	OREQLIT : "or_eq",
	PRIVATE : "private",
	PROTECTED : "protected",
	PUBLIC : "public",
	REGISTER : "register",
	REINTERPRETCAST : "reinterpret_cast",
	REQUIRES : "requires",
	RETURN : "return",
	SHORT : "short",
	SIGNED : "signed",
	SIZEOF : "sizeof",
	STATIC : "static",
	STATICASSRET : "static_assret",
	STATICCAST : "static_cast",
	STRUCT : "struct",
	SWITCH : "switch",
	TEMPLATE : "template",
	THIS : "this",
	THREADLOCAL : "thread_local",
	THROW : "throw",
	TRUE : "true",
	TRY : "try",
	TYPEDEF : "typedef",
	TYPENAME : "typename",
	UNION : "union",
	UNSIGNED : "unsigned",
	USING : "using",
    VIRUTAL : "virtual",
	VOID : "void",
	VOLATILE : "volatile",
	WCHART : "wchar_t",
	WHILE : "while",
	XORLIT : "xor",
	XOREQLIT : "xor_eq",
}

export type TokenType = typeof TokenType[keyof typeof TokenType]

export const keywords = new Map<String, TokenType>([
	['alignas', TokenType.ALIGNAS],
	['alignof', TokenType.ALIGNOF],
	['and', TokenType.ANDLIT],
	['and_eq', TokenType.ANDEQLIT],
	['asm', TokenType.ASM],
	['auto', TokenType.AUTO],
	['bitand', TokenType.BITANDLIT],
	['bitor', TokenType.BITORLIT],
	['bool', TokenType.BOOL],
	['break', TokenType.BREAK],
	['case', TokenType.CASE],
	['catch', TokenType.CATCH],
	['char', TokenType.CHAR],
	['char8_t', TokenType.CHAR8T],
	['char16_t', TokenType.CHAR16T],
	['char32_t', TokenType.CHAR32T],
	['class', TokenType.CLASS],
	['compl', TokenType.COMPL],
	['const', TokenType.CONST],
	['const_cast', TokenType.CONSTCAST],
	['consteval', TokenType.CONSTEVAL],
	['constexpr', TokenType.CONSTEXPR],
	['constinit', TokenType.CONSTINIT],
	['continue', TokenType.CONTINUE],
	['co_await', TokenType.COAWAIT],
	['co_return', TokenType.CORETURN],
	['co_yield', TokenType.COYIELD],
	['declytype', TokenType.DECLTYPE],
	['delete',TokenType.DELETE],
	['do',TokenType.DO],
	['double',TokenType.DOUBLE],
	['dynamic_cast',TokenType.DYNAMICAST],
	['else', TokenType.ELSE],
	['enum', TokenType.ENUM],
	['explicit', TokenType.EXPLICIT],
	['export', TokenType.EXPORT],
	['extern', TokenType.EXTERN],
	['false', TokenType.FALSE],
	['float', TokenType.FLOAT],
	['for', TokenType.FOR],
	['friend', TokenType.FRIEND],
	['goto', TokenType.GOTO],
	['if', TokenType.IF],
	['inline', TokenType.INLINE],
	['int', TokenType.INT],
	['long', TokenType.LONG],
	['mutable', TokenType.MUTABLE],
	['namespace', TokenType.NAMESPACE],
	['new', TokenType.NEW],
	['noexpect', TokenType.NOEXCEPT],
	['not', TokenType.NOTLIT],
	['not_eq', TokenType.NOTEQLIT],
	['nullptr', TokenType.NULLPTR],
	['operator', TokenType.OPERATOR],
	['or', TokenType.ORLIT],
	['or_eq', TokenType.OREQLIT],
	['private', TokenType.PRIVATE],
	['protected', TokenType.PROTECTED],
	['public', TokenType.PUBLIC],
	['register', TokenType.REGISTER],
	['reinterpret_cast', TokenType.REINTERPRETCAST],
	['requires', TokenType.REQUIRES],
	['short', TokenType.SHORT],
	['signed', TokenType.SIGNED],
	['sizeof', TokenType.SIZEOF],
	['static', TokenType.STATIC],
	['static_assret', TokenType.STATICASSRET],
	['static_cast', TokenType.STATICCAST],
	['struct', TokenType.STRUCT],
	['switch', TokenType.SWITCH],
	['thread_local', TokenType.THREADLOCAL],
	['throw', TokenType.THROW],
	['true', TokenType.TRUE],
	['try', TokenType.TRY],
	['typedef', TokenType.TYPEDEF],
	['typename', TokenType.TYPENAME],
	['union', TokenType.UNION],
	['unsigned', TokenType.UNSIGNED],
	['using', TokenType.USING],
	['virtual', TokenType.VIRUTAL],
	['void', TokenType.VOID],
	['volatile', TokenType.VOLATILE],
	['wchar_t', TokenType.WCHART],
	['while', TokenType.WHILE],
	['xor', TokenType.XORLIT],
	['xor_eq', TokenType.XOREQLIT],
])

export function getKeyword(ident:string): TokenType {
	return keywords.get(ident) ?? TokenType.IDENT
}

export class Token {
	constructor(
		protected readonly tokenType:TokenType,
		protected readonly literal :string,
		protected readonly line : Number,
		// 'col' has the position where itself starts
		protected readonly col : Number,
	){}

	getTokenType() {
		return this.tokenType
	}

	getTokenLiteral() {
		return this.literal
	}

	getTokenLine() {
		return this.line
	}

	getTokenPos() {
		return this.col
	}
}